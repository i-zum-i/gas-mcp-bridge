import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import fs from 'fs/promises';
import path from 'path';
import { z } from 'zod';
import { logger } from './logger.js';
import { createGASClient, GASClientError } from './gas-client.js';
/** レガシー互換の GAS 呼び出し */
async function callGAS(gasUrl, tool, args, token) {
    const client = createGASClient({
        gasUrl,
        apiToken: token,
    });
    return client.callTool(tool, args);
}
async function loadTools() {
    try {
        const toolsContent = await fs.readFile('mcp.tools.json', 'utf-8');
        const toolsData = JSON.parse(toolsContent);
        return toolsData.tools || [];
    }
    catch {
        logger.warn('mcp.tools.json not found. Using default echo tool.');
        return [
            {
                name: 'echo',
                description: 'A simple tool that echoes back the input. Used as a default when no other tools are defined.',
                path: 'echo',
                schema: {
                    type: 'object',
                    properties: {
                        message: {
                            type: 'string',
                            description: 'The message to echo back.',
                        },
                    },
                    required: ['message'],
                },
            },
        ];
    }
}
async function loadConfig() {
    const cfgPath = process.env.MCP_GAS_CONFIG_PATH || path.resolve('.mcp-gas.json');
    try {
        const raw = await fs.readFile(cfgPath, 'utf-8');
        const parsed = JSON.parse(raw);
        return parsed;
    }
    catch {
        logger.warn('.mcp-gas.json not found. Echo tool will work, but GAS tools will fail.');
        return null;
    }
}
/** JSON Schema → ZodRawShape (最小変換) */
function jsonSchemaToZodShape(schema) {
    const shape = {};
    if (!schema || schema.type !== 'object' || !schema.properties) {
        return shape; // 空 shape（引数なし）
    }
    const req = new Set(Array.isArray(schema.required) ? schema.required : []);
    for (const [key, prop] of Object.entries(schema.properties)) {
        let t;
        const propType = prop?.type;
        const desc = prop?.description;
        const wrapDesc = (zz) => (desc ? zz.describe(desc) : zz);
        switch (propType) {
            case 'string':
                t = wrapDesc(z.string());
                break;
            case 'number':
                t = wrapDesc(z.number());
                break;
            case 'integer':
                t = wrapDesc(z.number().int());
                break;
            case 'boolean':
                t = wrapDesc(z.boolean());
                break;
            case 'array': {
                const itemsType = prop?.items?.type || 'any';
                let zi;
                switch (itemsType) {
                    case 'string':
                        zi = z.string();
                        break;
                    case 'number':
                        zi = z.number();
                        break;
                    case 'integer':
                        zi = z.number().int();
                        break;
                    case 'boolean':
                        zi = z.boolean();
                        break;
                    case 'object':
                        zi = z.record(z.any());
                        break;
                    default:
                        zi = z.any();
                        break;
                }
                t = wrapDesc(z.array(zi));
                break;
            }
            case 'object':
                t = wrapDesc(z.record(z.any()));
                break;
            default:
                t = wrapDesc(z.any());
                break;
        }
        // 必須でなければ optional
        if (!req.has(key)) {
            t = t.optional();
        }
        shape[key] = t;
    }
    return shape;
}
export const startServer = async () => {
    logger.debug('Starting MCP server initialization');
    const server = new McpServer({
        name: 'gas-mcp-bridge',
        version: '1.0.0',
    }, {
        capabilities: {
            tools: {},
        },
    });
    logger.debug('Loading tools and configuration');
    const tools = await loadTools();
    const config = await loadConfig();
    // GAS エンドポイント（新: webAppUrl / 旧: gasUrl）
    const gasUrl = config?.webAppUrl || config?.gasUrl;
    // 認証トークン（環境変数 > 旧 apiToken > 開発用 devOauthToken）
    const gasApiToken = process.env.GAS_API_TOKEN ||
        config?.apiToken ||
        config?.devOauthToken ||
        undefined;
    logger.debug('Configuration loaded', {
        toolCount: tools.length,
        hasConfig: !!config,
        hasApiToken: !!gasApiToken,
        configScriptId: config?.scriptId,
        configGasUrl: gasUrl,
    });
    // ---- ツール登録 ----
    logger.debug('Registering tools', { tools: tools.map(t => ({ name: t.name, path: t.path })) });
    for (const tool of tools) {
        logger.debug(`Registering tool: ${tool.name}`);
        if (tool.name === 'echo' && tool.path === 'echo') {
            // Echo ツール
            server.registerTool(tool.name, {
                title: tool.name,
                description: tool.description,
                // ZodRawShape を渡す
                inputSchema: {
                    message: z.string().describe('The message to echo back.'),
                },
            }, async ({ message }) => {
                logger.mcpRequest('echo', { message });
                const body = {
                    testTool: true,
                    note: 'これはテスト用ツールです。/* @mcp ... */ 注釈を追加してから `npx mcp build` を実行してください。',
                    inputReceived: { message },
                    howToAnnotate: {
                        template: [
                            '/* @mcp',
                            'name: <tool.name>',
                            'description: <説明（任意）>',
                            'path: <ルーティングキー（省略可）>',
                            'schema:',
                            '  type: object',
                            '  properties:',
                            '    <paramA>: { type: string }',
                            '  required: [<paramA>]',
                            '*/',
                        ].join('\n'),
                        example: '/* @mcp\nname: sheet.appendRow\ndescription: Append one row to a sheet\n...'
                    },
                };
                const response = {
                    content: [{ type: "text", text: JSON.stringify(body, null, 2) }],
                };
                logger.mcpResponse('echo', response);
                return response;
            });
            continue;
        }
        // GAS ツール（JSON Schema → Zod shape 変換）
        const shape = jsonSchemaToZodShape(tool.schema);
        server.registerTool(tool.name, {
            title: tool.name,
            description: tool.description,
            inputSchema: shape, // ZodRawShape
        }, async (args) => {
            logger.mcpRequest(tool.name, args);
            if (!gasUrl) {
                const error = 'GAS configuration not found. Please run "npx mcp discover" (or create .mcp-gas.json).';
                logger.mcpError(tool.name, error);
                throw new Error(error);
            }
            try {
                const result = await callGAS(gasUrl, tool.path, args, gasApiToken);
                const response = {
                    content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
                };
                logger.mcpResponse(tool.name, response);
                return response;
            }
            catch (error) {
                logger.mcpError(tool.name, error);
                if (error instanceof GASClientError) {
                    logger.error(`Tool ${tool.name} failed: ${error.message}` +
                        (error.statusCode ? ` (HTTP ${error.statusCode})` : ''));
                    throw new Error(`GAS execution failed: ${error.message}`);
                }
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                logger.error(`Tool ${tool.name} failed: ${errorMessage}`);
                throw new Error(`Tool execution failed: ${errorMessage}`);
            }
        });
    }
    logger.debug('Connecting to transport');
    const transport = new StdioServerTransport();
    await server.connect(transport);
    logger.success('MCP Server started successfully');
    logger.debug('Server is now listening for MCP requests');
};
//# sourceMappingURL=server.js.map