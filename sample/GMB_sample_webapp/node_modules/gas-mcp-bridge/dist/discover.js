import fs from 'fs/promises';
import path from 'path';
import os from 'os';
import { google } from 'googleapis';
import { execa } from 'execa';
import { logger } from './logger.js';
const CLASP_CONFIG_FILE = '.clasp.json';
const CLASP_RC_FILE = '.clasprc.json';
const DEFAULT_MCP_CONFIG_FILE = '.mcp-gas.json';
// ===== public API =====
/**
 * Reads the script ID from the .clasp.json file in the specified directory.
 * @param projectRoot The root directory of the clasp project. Defaults to cwd.
 * @returns The script ID.
 * @throws An error if the file is not found or is malformed.
 */
export const getScriptId = async (projectRoot = '.') => {
    const configPath = path.join(projectRoot, CLASP_CONFIG_FILE);
    logger.info(`Reading script ID from ${configPath}...`);
    try {
        const content = await fs.readFile(configPath, 'utf-8');
        const config = JSON.parse(content);
        if (typeof config.scriptId === 'string' && config.scriptId) {
            logger.success(`Found script ID: ${config.scriptId}`);
            return config.scriptId;
        }
        else {
            throw new Error(`'scriptId' not found or is invalid in ${configPath}`);
        }
    }
    catch (error) {
        if (error.code === 'ENOENT') {
            throw new Error(`Could not find ${CLASP_CONFIG_FILE}. Make sure you are in a 'clasp' project directory or run 'clasp create'.`);
        }
        throw new Error(`Failed to read or parse ${configPath}: ${error.message}`);
    }
};
/**
 * Finds the latest web app deployment for a given script ID.
 * @param scriptId The script ID.
 * @param accessToken The OAuth access token.
 * @returns The deployment ID and URL, or null if not found.
 */
export const getWebAppDeployment = async (scriptId, accessToken) => {
    logger.info(`Fetching deployments for script ID: ${scriptId}...`);
    const oauth2Client = new google.auth.OAuth2();
    oauth2Client.setCredentials({ access_token: accessToken });
    const script = google.script({ version: 'v1', auth: oauth2Client });
    try {
        const { data } = await script.projects.deployments.list({ scriptId });
        if (!data.deployments || data.deployments.length === 0) {
            logger.warn('No deployments found for this script.');
            return null;
        }
        // Find the latest active web app deployment
        const webAppDeployments = data.deployments
            .filter((d) => d.entryPoints?.some((e) => e.entryPointType === 'WEB_APP'))
            .sort((a, b) => (b.updateTime?.localeCompare(a.updateTime ?? '') ?? 0));
        if (webAppDeployments.length === 0) {
            logger.warn('No web app deployments found.');
            return null;
        }
        const latestDeployment = webAppDeployments[0];
        const webAppEntryPoint = latestDeployment.entryPoints?.find((e) => e.entryPointType === 'WEB_APP');
        const deploymentId = latestDeployment.deploymentId;
        if (!webAppEntryPoint?.webApp?.url || !deploymentId) {
            logger.warn('Latest web app deployment is missing URL or deployment ID.');
            return null;
        }
        logger.success(`Found latest web app deployment: ${deploymentId}`);
        return {
            deploymentId,
            url: webAppEntryPoint.webApp.url,
        };
    }
    catch (error) {
        logger.error(`Failed to fetch deployments: ${error.message}`);
        // Potentially check for 401/403 and suggest re-logging in
        if (error.code === 401 || error.code === 403) {
            logger.warn("Authentication failed. Your credentials may have expired. Please try 'clasp login' again.");
        }
        return null;
    }
};
/**
 * Runs 'npx clasp deploy' to create a new deployment.
 */
export const runClaspDeploy = async () => {
    logger.info("Attempting to create a new deployment by running 'npx clasp deploy'...");
    try {
        const claspProcess = execa('npx', ['clasp', 'deploy']);
        // Pipe the output to our logger in real-time
        claspProcess.stdout?.pipe(process.stdout);
        claspProcess.stderr?.pipe(process.stderr);
        await claspProcess;
        logger.success("'clasp deploy' completed successfully.");
    }
    catch (error) {
        logger.error("Failed to run 'clasp deploy'.");
        logger.error(error.message);
        throw new Error("Automatic deployment failed. Please try running 'npx clasp deploy' manually and resolve any issues.");
    }
};
/**
 * Saves (or merges) the discovered configuration to .mcp-gas.json.
 * - Writes both `webAppUrl` and legacy `gasUrl` for compatibility.
 * - Prefers scriptPropertiesToken; can include dev oauth token if MCP_INCLUDE_OAUTH_TOKEN=1.
 */
export const saveMcpConfig = async (config, filePath = DEFAULT_MCP_CONFIG_FILE) => {
    logger.info(`Saving configuration to ${filePath}...`);
    try {
        // Merge with existing file if present (non-destructive)
        let existing = {};
        try {
            const current = await fs.readFile(filePath, 'utf-8');
            existing = JSON.parse(current);
        }
        catch (e) {
            if (e?.code !== 'ENOENT') {
                logger.warn(`Existing ${filePath} could not be parsed. Overwriting.`);
            }
        }
        const merged = {
            scriptId: config.scriptId,
            deploymentId: config.deploymentId,
            webAppUrl: config.webAppUrl,
            // keep legacy key for older clients
            gasUrl: config.webAppUrl,
            auth: config.auth,
            // dev oauth token is optional and excluded unless provided
            ...(config.devOauthToken ? { devOauthToken: config.devOauthToken } : {}),
            // preserve unknown future fields from existing (best-effort)
            ...(existing && typeof existing === 'object' ? existing : {}),
        };
        // Ensure critical fields are from 'config' (override any existing)
        merged.scriptId = config.scriptId;
        merged.deploymentId = config.deploymentId;
        merged.webAppUrl = config.webAppUrl;
        merged.gasUrl = config.webAppUrl;
        merged.auth = config.auth;
        const jsonContent = JSON.stringify(merged, null, 2);
        await fs.writeFile(filePath, jsonContent, 'utf-8');
        logger.success(`Configuration saved successfully to ${filePath}.`);
        // Safety: if we wrote a dev oauth token, suggest .gitignore
        if (merged.devOauthToken) {
            await ensureGitignoreHasEntry('.mcp-gas.json');
        }
    }
    catch (error) {
        throw new Error(`Failed to save configuration to ${filePath}: ${error.message}`);
    }
};
// ===== credentials =====
/**
 * Reads the clasp credentials from the ~/.clasprc.json file.
 * @returns The access token.
 * @throws An error if the file is not found or is malformed.
 */
export const getClaspCredentials = async () => {
    const configPath = path.join(os.homedir(), CLASP_RC_FILE);
    logger.info(`Reading credentials from ${configPath}...`);
    try {
        const content = await fs.readFile(configPath, 'utf-8');
        const config = JSON.parse(content);
        const accessToken = config?.token?.access_token;
        if (typeof accessToken === 'string' && accessToken) {
            logger.success('Successfully read access token.');
            return { accessToken };
        }
        else {
            throw new Error(`'token.access_token' not found or is invalid in ${configPath}`);
        }
    }
    catch (error) {
        if (error.code === 'ENOENT') {
            throw new Error(`Could not find ${CLASP_RC_FILE} in your home directory. Please run 'clasp login'.`);
        }
        throw new Error(`Failed to read or parse ${configPath}: ${error.message}`);
    }
};
// ===== helpers =====
/**
 * Compose and persist .mcp-gas.json in one go.
 * Preferred auth is Script Properties token. If MCP_INCLUDE_OAUTH_TOKEN=1, dev token is embedded.
 */
export const composeAndSaveMcpConfig = async (opts) => {
    const tokenPropertyKey = opts.tokenPropertyKey ?? 'MCP_API_TOKEN';
    const includeDevToken = process.env.MCP_INCLUDE_OAUTH_TOKEN === '1';
    const cfg = {
        scriptId: opts.scriptId,
        deploymentId: opts.deployment.deploymentId,
        webAppUrl: opts.deployment.url,
        auth: { type: 'scriptPropertiesToken', tokenPropertyKey },
        ...(includeDevToken ? { devOauthToken: opts.accessToken } : {}),
    };
    await saveMcpConfig(cfg, opts.filePath ?? DEFAULT_MCP_CONFIG_FILE);
    // ユーザー向けヒント
    logger.info(`Auth mode set to 'scriptPropertiesToken'. Please set the Script Property '${tokenPropertyKey}' on your GAS project.`);
    if (includeDevToken) {
        logger.warn(`Dev OAuth token embedded for convenience. It is short-lived. Do NOT commit ${DEFAULT_MCP_CONFIG_FILE}.`);
    }
};
/** Ensure .gitignore contains the given entry (best-effort). */
const ensureGitignoreHasEntry = async (entry) => {
    const giPath = path.resolve('.gitignore');
    try {
        const current = await fs.readFile(giPath, 'utf-8').catch(() => '');
        if (!current.split(/\r?\n/).some((line) => line.trim() === entry)) {
            const next = current.endsWith('\n') || current.length === 0 ? current + entry + '\n' : current + '\n' + entry + '\n';
            await fs.writeFile(giPath, next, 'utf-8');
            logger.info(`Added '${entry}' to .gitignore`);
        }
    }
    catch {
        // ignore
    }
};
//# sourceMappingURL=discover.js.map