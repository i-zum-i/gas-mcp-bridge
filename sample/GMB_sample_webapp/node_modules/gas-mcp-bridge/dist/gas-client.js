import { logger } from './logger.js';
export class GASClientError extends Error {
    statusCode;
    gasResponse;
    constructor(message, statusCode, gasResponse) {
        super(message);
        this.statusCode = statusCode;
        this.gasResponse = gasResponse;
        this.name = 'GASClientError';
    }
}
export class GASClient {
    gasUrl;
    apiToken;
    timeoutMs;
    maxRetries;
    constructor(options) {
        this.gasUrl = options.gasUrl;
        this.apiToken = options.apiToken;
        this.timeoutMs = options.timeoutMs ?? parseInt(process.env.MCP_TIMEOUT_MS || '30000', 10);
        this.maxRetries = options.maxRetries ?? parseInt(process.env.MCP_RETRY || '0', 10);
    }
    async callTool(tool, args) {
        const request = { tool, args };
        let lastError = null;
        logger.debug(`Starting GAS call for tool "${tool}"`, {
            gasUrl: this.gasUrl,
            hasApiToken: !!this.apiToken,
            timeoutMs: this.timeoutMs,
            maxRetries: this.maxRetries,
            request
        });
        for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
            try {
                if (attempt > 0) {
                    logger.info(`Retrying GAS call for tool "${tool}" (attempt ${attempt + 1}/${this.maxRetries + 1})`);
                }
                const result = await this.performRequest(request);
                if (attempt > 0) {
                    logger.success(`GAS call succeeded on retry for tool "${tool}"`);
                }
                else {
                    logger.debug(`GAS call succeeded for tool "${tool}"`, { result });
                }
                return result;
            }
            catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                logger.debug(`GAS call attempt ${attempt + 1} failed for tool "${tool}"`, {
                    error: lastError.message,
                    isGASClientError: error instanceof GASClientError,
                    statusCode: error instanceof GASClientError ? error.statusCode : undefined
                });
                if (attempt < this.maxRetries) {
                    logger.warn(`GAS call failed for tool "${tool}": ${lastError.message}. Retrying...`);
                    // Simple exponential backoff
                    const delayMs = Math.min(1000 * Math.pow(2, attempt), 5000);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
                else {
                    logger.error(`GAS call failed for tool "${tool}" after ${this.maxRetries + 1} attempts: ${lastError.message}`);
                }
            }
        }
        // All retries failed, throw the last error
        throw lastError;
    }
    async performRequest(request) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeoutMs);
        logger.debug('Sending HTTP request to GAS', {
            url: this.gasUrl,
            method: 'POST',
            hasAuth: !!this.apiToken,
            timeout: this.timeoutMs,
            requestBody: request
        });
        try {
            const response = await fetch(this.gasUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...(this.apiToken && { 'Authorization': `Bearer ${this.apiToken}` })
                },
                body: JSON.stringify(request),
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            logger.debug('Received HTTP response from GAS', {
                status: response.status,
                statusText: response.statusText,
                ok: response.ok,
                headers: Object.fromEntries(response.headers.entries())
            });
            // Handle non-200 HTTP status codes
            if (!response.ok) {
                const errorText = await response.text().catch(() => 'Unable to read response body');
                logger.debug('HTTP error response body', { errorText });
                throw new GASClientError(`HTTP ${response.status}: ${response.statusText}`, response.status);
            }
            const responseText = await response.text();
            logger.debug('Raw response text from GAS', { responseText });
            let gasResponse;
            try {
                gasResponse = JSON.parse(responseText);
            }
            catch (parseError) {
                logger.debug('Failed to parse JSON response', { parseError, responseText });
                throw new GASClientError(`Invalid JSON response from GAS: ${parseError instanceof Error ? parseError.message : String(parseError)}`);
            }
            logger.debug('Parsed GAS response', { gasResponse });
            // Handle GAS-level errors (non-ok responses)
            if (!gasResponse.ok) {
                throw new GASClientError(gasResponse.message || 'GAS execution failed', response.status, gasResponse);
            }
            return gasResponse.result;
        }
        catch (error) {
            clearTimeout(timeoutId);
            if (error instanceof GASClientError) {
                throw error;
            }
            if (error instanceof Error && error.name === 'AbortError') {
                throw new GASClientError(`Request timeout after ${this.timeoutMs}ms`);
            }
            logger.debug('Network error details', {
                error: error instanceof Error ? error.message : String(error),
                name: error instanceof Error ? error.name : 'unknown',
                stack: error instanceof Error ? error.stack : undefined
            });
            throw new GASClientError(`Network error: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}
// Factory function for creating GAS client
export function createGASClient(options) {
    return new GASClient(options);
}
// Utility function for one-off calls (backward compatibility)
export async function callGAS(gasUrl, tool, args, token) {
    const client = createGASClient({
        gasUrl,
        apiToken: token,
    });
    return client.callTool(tool, args);
}
//# sourceMappingURL=gas-client.js.map